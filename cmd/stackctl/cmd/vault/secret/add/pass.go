package add

import (
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"os"

	"github.com/atotto/clipboard"
	"github.com/spf13/cobra"

	vaultpkg "github.com/eliasmeireles/stackctl/cmd/stackctl/internal/feature/vault"
	"github.com/eliasmeireles/stackctl/cmd/stackctl/internal/feature/vault/flags"
)

const (
	defaultPassPath = "secret/data/users/all/passwords"
	envPassPath     = "STACK_CTL_DEFAULT_PASS_PATH"
	defaultPassSize = vaultpkg.DefaultAutoGenSize
)

func NewPassCmd() *cobra.Command {
	return NewPassCmdFunc()
}

var NewPassCmdFunc = func() *cobra.Command {
	var path string
	var pass string
	var size int

	cmd := &cobra.Command{
		Use:   "pass <KEY>",
		Short: "Add a password to Vault (auto-generated if --pass is not provided)",
		Long: `Write a password field into a Vault KV v2 secret.

If --pass is not provided the value is auto-generated as a cryptographically
random hex string of --size bytes (default 20 bytes = 40 hex characters).
Auto-generated passwords are also copied to clipboard.

Path resolution order:
  1. --path flag
  2. STACK_CTL_DEFAULT_PASS_PATH environment variable
  3. Default: secret/data/users/all/passwords

Examples:
  stackctl add pass MY_PASSWORD --pass s3cr3t
  stackctl add pass MY_PASSWORD --size 32
  stackctl add pass MY_PASSWORD --path secret/data/team/credentials --pass s3cr3t`,
		Args:         cobra.ExactArgs(1),
		SilenceUsage: true,
		RunE:         runAddPassCmd(&path, &pass, &size),
	}

	cmd.Flags().StringVar(&path, "path", "",
		fmt.Sprintf("Vault KV v2 secret path (env: %s, default: %s)", envPassPath, defaultPassPath))
	cmd.Flags().StringVar(&pass, "pass", "", "Explicit password value (skips auto-generation)")
	cmd.Flags().IntVar(&size, "size", defaultPassSize,
		"Number of random bytes for auto-generation (ignored when --pass is set)")

	flags.SharedFlags(cmd)

	return cmd
}

var runAddPassCmd = func(path, pass *string, size *int) func(cmd *cobra.Command, args []string) error {
	return func(cmd *cobra.Command, args []string) error {
		flags.Resolve()

		secretPath := resolvePassPath(path)
		key := args[0]

		client, err := vaultpkg.ApiClient.EnvVaultClient()
		if err != nil {
			return fmt.Errorf("❌ Failed to connect to Vault: %w", err)
		}

		value, autoGenerated, err := resolveValue(pass, size)
		if err != nil {
			return fmt.Errorf("❌ Failed to generate password: %w", err)
		}

		// Ensure the KV v2 engine exists before writing
		if err := vaultpkg.EnsureKVEngine(vaultpkg.MountPointFromPath(secretPath)); err != nil {
			return fmt.Errorf("❌ Failed to ensure KV engine: %w", err)
		}

		existing, _ := client.ReadSecret(secretPath)
		if existing == nil {
			existing = make(map[string]interface{})
		}
		existing[key] = value

		if err := client.WriteSecret(secretPath, existing); err != nil {
			return fmt.Errorf("❌ Failed to write password: %w", err)
		}

		if autoGenerated {
			if err := clipboard.WriteAll(value); err != nil {
				fmt.Printf("⚠️  Could not copy to clipboard: %v\n", err)
			} else {
				fmt.Printf("✅ '%s' added and copied to clipboard\n", key)
				return nil
			}
		}

		fmt.Printf("✅ '%s' added\n", key)
		return nil
	}
}

// resolveValue returns the password value and whether it was auto-generated.
func resolveValue(pass *string, size *int) (string, bool, error) {
	if pass != nil && *pass != "" {
		return *pass, false, nil
	}
	n := defaultPassSize
	if size != nil && *size > 0 {
		n = *size
	}
	b := make([]byte, n)
	if _, err := rand.Read(b); err != nil {
		return "", false, err
	}
	return hex.EncodeToString(b), true, nil
}

func resolvePassPath(flagPath *string) string {
	if flagPath != nil && *flagPath != "" {
		return *flagPath
	}
	if env := os.Getenv(envPassPath); env != "" {
		return env
	}
	return defaultPassPath
}
