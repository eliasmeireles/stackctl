package update

import (
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"os"
	"strings"

	"github.com/atotto/clipboard"
	"github.com/spf13/cobra"

	vaultpkg "github.com/eliasmeireles/stackctl/cmd/stackctl/internal/feature/vault"
	"github.com/eliasmeireles/stackctl/cmd/stackctl/internal/feature/vault/flags"
)

const (
	defaultPassPath = "secret/data/users/all/passwords"
	envPassPath     = "STACK_CTL_DEFAULT_PASS_PATH"
	defaultPassSize = vaultpkg.DefaultAutoGenSize
)

func NewPassCmd() *cobra.Command {
	return NewPassCmdFunc()
}

var NewPassCmdFunc = func() *cobra.Command {
	var path string
	var pass string
	var size int

	cmd := &cobra.Command{
		Use:   "pass <KEY>",
		Short: "Update a password in Vault (auto-generated if --pass is not provided)",
		Long: `Update a password field in a Vault KV v2 secret.

If --pass is not provided the value is auto-generated as a cryptographically
random hex string of --size bytes (default 20 bytes = 40 hex characters).
Auto-generated passwords are also copied to clipboard.

Path resolution order:
  1. --path flag
  2. STACK_CTL_DEFAULT_PASS_PATH environment variable
  3. Default: secret/data/users/all/passwords

Examples:
  stackctl update pass MY_PASSWORD --pass newvalue
  stackctl update pass MY_PASSWORD --size 32
  stackctl update pass MY_PASSWORD --path secret/data/team/credentials --pass newvalue`,
		Args:         cobra.ExactArgs(1),
		SilenceUsage: true,
		RunE:         runUpdatePassCmd(&path, &pass, &size),
	}

	cmd.Flags().StringVar(&path, "path", "",
		fmt.Sprintf("Vault KV v2 secret path (env: %s, default: %s)", envPassPath, defaultPassPath))
	cmd.Flags().StringVar(&pass, "pass", "", "New password value (skips auto-generation)")
	cmd.Flags().IntVar(&size, "size", defaultPassSize,
		"Number of random bytes for auto-generation (ignored when --pass is set)")

	flags.SharedFlags(cmd)

	return cmd
}

var runUpdatePassCmd = func(path, pass *string, size *int) func(cmd *cobra.Command, args []string) error {
	return func(cmd *cobra.Command, args []string) error {
		flags.Resolve()

		secretPath := resolvePassPath(path)
		key := args[0]

		client, err := vaultpkg.ApiClient.EnvVaultClient()
		if err != nil {
			return fmt.Errorf("❌ Failed to connect to Vault: %w", err)
		}

		existing, err := client.ReadSecret(secretPath)
		if err != nil {
			if isPassNotFound(err) {
				return fmt.Errorf("password '%s' not found", key)
			}
			return fmt.Errorf("❌ Failed to read secret: %w", err)
		}

		value, autoGenerated, err := resolveValue(pass, size)
		if err != nil {
			return fmt.Errorf("❌ Failed to generate password: %w", err)
		}

		existing[key] = value

		if err := client.WriteSecret(secretPath, existing); err != nil {
			return fmt.Errorf("❌ Failed to write password: %w", err)
		}

		if autoGenerated {
			if err := clipboard.WriteAll(value); err != nil {
				fmt.Printf("⚠️  Could not copy to clipboard: %v\n", err)
			} else {
				fmt.Printf("✅ '%s' updated and copied to clipboard\n", key)
				return nil
			}
		}

		fmt.Printf("✅ '%s' updated\n", key)
		return nil
	}
}

func resolveValue(pass *string, size *int) (string, bool, error) {
	if pass != nil && *pass != "" {
		return *pass, false, nil
	}
	n := defaultPassSize
	if size != nil && *size > 0 {
		n = *size
	}
	b := make([]byte, n)
	if _, err := rand.Read(b); err != nil {
		return "", false, err
	}
	return hex.EncodeToString(b), true, nil
}

func isPassNotFound(err error) bool {
	msg := strings.ToLower(err.Error())
	return strings.Contains(msg, "no secret data found") || strings.Contains(msg, "not found")
}

func resolvePassPath(flagPath *string) string {
	if flagPath != nil && *flagPath != "" {
		return *flagPath
	}
	if env := os.Getenv(envPassPath); env != "" {
		return env
	}
	return defaultPassPath
}
